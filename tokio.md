# Tokio

## Concurrency

Concurrency - 同時実行

Redisサーバーに多くの同時リクエストを処理させたい場合、並行処理を追加する必要がある。  

## 並行処理(Concurrency)と並列処理(Parallelism)の違い

Tokioでは、主に並行処理 - Concurrency を採用している。Tokioは、非同期I/O操作やタスクを効率的にスケジューリングするためのランタイムを提供している。  
これにより多くのタスクが同時に進行しているように見える。そして、これはシングルスレッド上で時間を分割して実行されることもある。

### 並行処理 - Concurrency

並行処理とは、複数のタスクが同時に進行しているように見える状態。これらの複数タスクは、物理的には同時実行されている訳ではなく、各タスクを分割して交互に処理されるため同時に動いているように見える。  

特徴
- 並行処理はシングルスレッドで多くのタスクを同時に実行している(のように見える)
- シングルコアプロセッサ上でも実現可能
- 並行処理の目的は、システムの応答性や効率を改善すること
- タスクが頻繁に切り替わることで、ユーザーから見て「同時に」実行されているように見える

### 並列処理 - Parallelism

複数のタスクが物理的に同時に実行されている状態。これらの各タスクは、複数のCPUコアを利用して、実際に同時実行されている。  

特徴
- 高い計算能力が必要な作業に向いている
- マルチコアプロセッサ上でのみ実現可能
- 目的は、処理のスループットや計算能力を最大化すること


実装

```rust
use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    let listener = TcpListener::bind("127.0.0.1:6379").await.unwrap();

    loop {
        let (socket, _) = listener.accept().await.unwrap();
        // 受信したソケットごとに新しいタスクが生成され、新しいタスクに移動され、そこでリクエストを処理する
        tokio::spawn(async move {
            process(socket).await;
        });
    }
}

```


## Tokioのタスク

Tokioのタスクは tokio::task::spawn を使って非同期タスクを生成し、これはグリーンスレッドである。tokio::spawn関数は `JoinHandle` を返し、 `JoinHandle` はタスクの終了や結果を待つためにやり取りすることができるハンドルである。  
`JoinHandle::await` を使ってタスクが終了するまで待機し、タスクの結果を取得することができる


example code
```rust
#[tokio::main]
async fn main() {
    // 非同期タスクを生成して `JoinHandle` を受け取る
    let handle = tokio::spawn(async {
        // 何かしらの非同期処理...
        "return value"
    });

    // なにかしらの処理...

    // `JoinHandle::await` を使ってタスクの終了を待ち、タスクの結果を取得する
    let out = handle.await.unwrap();
    println!("GOT {}", out);
}
```

### Tokioタスクを生成するときのライフタイムは 'static である必要がある

Rustのライフタイムとは、変数が有効な期間を示しており、特に 'static ライフタイムは「プログラム実行期間中全体にわたって生存する」ということを示している。これは、プログラムが終了するまでそのデータが有効であることを保証している。

なぜasyncブロックやクロージャに移動する時、その変数のライフタイムは 'staticにする必要があるのか？それは、タスクやクロージャがいつ終了するのかをコンパイラは予測できないため、プログラム実行中はずっとデータが有効であることを保証する必要がある。

また、生成されたタスクの実行は、新たなスレッドで実行されるかまたは、別のコンテキストで実行される可能性がある。そのため、asyncブロックやクロージャにデータを渡す場合、そのデータの所有権を移動させる必要がある。これは move キーワードを使うことで行われる

例えば以下のようなコードはコンパイルエラーとなる  
example code
```rust
use tokio::task;

#[tokio::main]
async fn main() {
    let v = vec![1, 2, 3];

    task::spawn(async {
        println!("Here's a vec: {:?}", v);
    });
}
```

なぜコンパイルエラーとなるのか？   
それは、変数vの所有権がmain関数で所持しており、task::spawn内のaysncブロックがvを借りようとすると、エラーとなる。このコンパイルエラーを解決するには、moveキーワードを使って、vの所有権をasyncブロックに移動させることで解決する

修正後  
example code
```rust
use tokio::task;

#[tokio::main]
async fn main() {
    let v = vec![1, 2, 3];

    task::spawn(async move { // moveを追加
        println!("Here's a vec: {:?}", v);
    });
}
```

## 非同期タスクをtokio::spawn関数を使って生成するとき、生成されるタスクはSendトレイトを実装している必要がある
Tokioがタスクをスレッド間で安全に移動できるようにするために、tokioで非同期タスクをtokio::spawn関数を使って生成するとき、生成されるタスクはSendトレイトを実装している必要がある。

### Sendトレイトとは

Sendトレイトを実装している型は、スレッド間で安全に転送できることを示している。例えばstd::rc::RcはSendトレイトを実装していないため、スレッド間を安全に移動することができない。std::sync::ArcはSendトレイトを実装しているため、スレッド間での安全な移動が可能になっている。

Tokioのタスクは await によって一時停止され、その再開がされる。このプロセス中に異なるタスクのスレッドに移動することができるのですが、この移動を安全に行うために、タスクのすべてがSendトレイトを実装する必要があるということ。


Tokioタスクを生成して、awaitを使用してみる  
example code
```rust
use tokio::task::yield_now;
use std::rc::RC;

#[tokio::main]
async fn main() {
    // スコープを抜けると `rc` は await の前でドロップされる
    {
        let rc = Rc::new("hello");
        println!("{}", rc);
    }

    // rcはすでにドロップしているので、存在しない
    yield_now().await;
}
```

↑このコードは、Rc型の変数がawaitの前にスコープを抜けるため、変数rcは存在せず、タスクが一時停止して別スレッドで再開される時にはrcを保持する時する必要がないためコンパイルは正常に行われる

コンパイルエラーとなる  
example code 
```rust
use tokio::task::yield_now;
use std::rc::Rc;

#[tokio::main]
async fn main() {
    tokio::spawn(async {
        let rc = Rc::new("hello");

        // `rc` は `.await` の後で使用されます。そのため、
        // タスクの状態として保持される必要があります。
        yield_now().await;

        println!("{}", rc);
    });
}
```

エラーの原因は、println!によってrcがawaitの後で使われいるため。タスクはawaitによって一時停止し、その後再開される際にrcの値を保持する必要があるが、RcはSendトレイトを実装していないため、スレッド間で安全に移動できない。  
そのため、Rustはコンパイルエラーとなる。

エラーの内容は、「rcがawaitのあとでも利用されているので、そのタスクはSendトレイトを実装しなければならない」という旨のエラー。

このエラーを解決するにはSendトレイトを実装しているstd::sync::Arcを使うこと。


```rust
use tokio::task::yield_now;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    tokio::spawn(async {
        let rc = Arc::new("hello");

        yield_now().await;

        println!("{}", rc);
    });
}
// hello
```
https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=51f0df2cff1c038bd221f326170bc01b


## 複数の接続間での状態の共有

Redisのようなキーバリューストアのサーバーでは、複数の接続があり、それぞれの接続が個別に状態を持っているため、このままでは接続間で状態を共有されない。これを解決するためには、状態を接続間で共有する必要がある。

### なぜ状態を共有する必要があるのか？
Webサーバーなどでは、複数のクライアントが同時に接続することが一般的で、各接続が個別の状態を持つと次のような問題が発生する

- データの一貫性が保てない
    - 例えば、オンラインストアで複数のユーザーが同時に在庫を確認して、購入を行うことを想定
    - 各接続が個別の在庫情報を持っていると、同じアイテムが重複して販売される可能性がある。
        - 本来在庫は1つなのに、2人のユーザーが同時にアクセスすることで、どちらも購入できてしまう
    - これを回避するために、状態を各接続間で共有することで在庫の一貫性を保ち、正しい在庫管理が可能になり
- クライアント間での連携ができない
    - 例えば、チャットアプリでは、すべての参加者が同じメッセージの履歴を共有する必要がある
    - 各クライアントは他のクライアントの操作や状態を知ることができない
    - そのため、各クライアントで状態を共有することで、リアルタイムなコミュニケーションが可能となる

### 状態を各接続間で共有する方法

Tokioで状態を共有する方法はいくつかある。
1. Mutex(排他制御)を使って状態の共有を保護する
2. 状態を管理するタスクを生成して、メッセージパッシングで操作する

### 1. Mutexを使った状態共有の保護

複数のスレッドやタスクが同じデータにアクセスする際にそのデータを保護することがMutexを使うことで可能になる。
Mutexは一度に一つのスレッドしかデータにアクセスできないようにロックする機能を提供している。これにより、データの一貫性が保たれ、競合の状態を防ぐことができる。


これは非同期な操作を必要としない、シンプルなデータ構造を扱うときに適している。
